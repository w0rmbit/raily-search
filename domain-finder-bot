import os
import re
import io
import threading
import time
import requests
import telebot
from flask import Flask
from telebot import types
from telethon import TelegramClient, events

# === CONFIG ===
BOT_TOKEN = os.getenv('BOT_TOKEN')
API_ID = int(os.getenv("API_ID", 0))
API_HASH = os.getenv("API_HASH")
SESSION_NAME = os.getenv("SESSION_NAME", "tg_userbot")
CHANNEL_USERNAME = os.getenv("CHANNEL_USERNAME", None)
BASE_URL = os.getenv("BASE_URL", "http://localhost:8000")

if not BOT_TOKEN or not API_ID or not API_HASH:
    print("‚ùå Missing BOT_TOKEN, API_ID, or API_HASH environment variables")
    exit(1)

# === TELEGRAM BOT ===
bot = telebot.TeleBot(BOT_TOKEN)
app = Flask(__name__)

# === TELETHON USERBOT ===
userbot = TelegramClient(SESSION_NAME, API_ID, API_HASH)
UPLOAD_DIR = "uploads"
os.makedirs(UPLOAD_DIR, exist_ok=True)

# === STATE & DATA ===
user_states = {}
user_data = {}
indexed_files = {}  # {filename: filepath}
domain_history = {}  # {chat_id: [domain1, domain2, ...]}

def reset_user(chat_id):
    user_states[chat_id] = None
    user_data[chat_id] = {'links': {}, 'temp_url': None}

# === HEALTH CHECK ===
@app.route('/')
def health():
    return "OK", 200

def run_flask():
    port = int(os.environ.get("PORT", 8000))
    app.run(host="0.0.0.0", port=port)

# === FILE INDEXING ===
async def index_channel_files():
    if not CHANNEL_USERNAME:
        print("‚ö†Ô∏è No channel specified, skipping indexing")
        return
    async for message in userbot.iter_messages(CHANNEL_USERNAME):
        if message.document and message.document.mime_type == "text/plain":
            filename = message.file.name or f"{message.id}.txt"
            filepath = os.path.join(UPLOAD_DIR, filename)
            if not os.path.exists(filepath):
                await message.download_media(file=filepath)
                indexed_files[filename] = filepath
    print(f"‚úÖ Indexed {len(indexed_files)} files from {CHANNEL_USERNAME}")

# === AUTO CLEANER (EVERY 24H) ===
def auto_cleaner():
    while True:
        time.sleep(86400)
        for f in os.listdir(UPLOAD_DIR):
            try:
                os.remove(os.path.join(UPLOAD_DIR, f))
            except:
                pass
        indexed_files.clear()
        print("üßπ Cleared uploaded files.")

# === MAIN MENU ===
def send_main_menu(chat_id):
    markup = types.InlineKeyboardMarkup(row_width=2)
    markup.add(
        types.InlineKeyboardButton("üîç Search Domain", callback_data="search"),
        types.InlineKeyboardButton("üïò Recent Domains", callback_data="recent"),
    )
    bot.send_message(chat_id, "üìå Choose an action:", reply_markup=markup)

# === BOT HANDLERS ===
@bot.message_handler(commands=['start'])
def handle_start(message):
    reset_user(message.chat.id)
    send_main_menu(message.chat.id)

@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    chat_id = call.message.chat.id
    if call.data == "search":
        if not indexed_files:
            bot.send_message(chat_id, "‚ö†Ô∏è No files indexed yet.")
            return
        user_states[chat_id] = "awaiting_domain"
        bot.send_message(chat_id, "‚úèÔ∏è Send me a domain to search for:")

    elif call.data == "recent":
        domains = domain_history.get(chat_id, [])
        if not domains:
            bot.send_message(chat_id, "‚ö†Ô∏è No recent searches.")
            return
        markup = types.InlineKeyboardMarkup()
        for d in domains[-10:]:
            markup.add(types.InlineKeyboardButton(f"üîÅ {d}", callback_data=f"search:{d}"))
        bot.send_message(chat_id, "Choose a domain:", reply_markup=markup)

    elif call.data.startswith("search:"):
        domain = call.data.split("search:")[1]
        run_search(chat_id, domain)

@bot.message_handler(func=lambda m: user_states.get(m.chat.id) == "awaiting_domain")
def handle_domain(message):
    chat_id = message.chat.id
    domain = message.text.strip()
    run_search(chat_id, domain)

def run_search(chat_id, domain):
    domain_history.setdefault(chat_id, []).append(domain)
    pattern = re.compile(re.escape(domain), re.IGNORECASE)
    results = []
    total_matches = 0

    for fname, filepath in indexed_files.items():
        matches = []
        with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
            for line in f:
                if pattern.search(line):
                    matches.append(line.strip())
        if matches:
            results.append(f"üìÑ *{fname}* ‚Äî {len(matches)} matches")
            total_matches += len(matches)
            # Save results to temp file
            out = io.BytesIO("\n".join(matches).encode("utf-8"))
            out.name = f"results_{fname}.txt"
            bot.send_document(chat_id, out)

    if results:
        bot.send_message(chat_id, f"‚úÖ Found {total_matches} matches:\n" + "\n".join(results), parse_mode="Markdown")
    else:
        bot.send_message(chat_id, f"‚ùå No results for `{domain}`", parse_mode="Markdown")
    send_main_menu(chat_id)

# === USERBOT EVENT HANDLER ===
@userbot.on(events.NewMessage(chats=CHANNEL_USERNAME))
async def handler(event):
    if event.document and event.document.mime_type == "text/plain":
        filename = event.file.name or f"{event.id}.txt"
        filepath = os.path.join(UPLOAD_DIR, filename)
        await event.download_media(file=filepath)
        indexed_files[filename] = filepath
        print(f"üì• Indexed new file: {filename}")

# === RUN EVERYTHING ===
if __name__ == "__main__":
    print("ü§ñ Bot is running with Flask health check and auto-cleaner...")
    threading.Thread(target=run_flask, daemon=True).start()
    threading.Thread(target=auto_cleaner, daemon=True).start()

    async def start_userbot():
        await userbot.start()
        await index_channel_files()
        print("üì° Userbot connected. Listening for new files...")

    userbot.loop.create_task(start_userbot())
    userbot.loop.run_in_executor(None, bot.polling, True)
    userbot.run_until_disconnected()
